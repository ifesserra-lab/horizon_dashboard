---
interface Props {
    title?: string;
    showTitle?: boolean;
    data: { label: string | number; value: number }[];
    color?: string;
    height?: string;
    valueLabel?: string;
}

const {
    title = "Gráfico",
    showTitle = true,
    data,
    color = "premium-purple",
    height = "h-64",
    valueLabel = "item",
} = Astro.props;

// Sort data by label if it's numeric/year-like
const sortedData = [...data].sort((a, b) => {
    const aNum = Number(a.label);
    const bNum = Number(b.label);
    if (!isNaN(aNum) && !isNaN(bNum)) {
        return aNum - bNum;
    }
    return String(a.label).localeCompare(String(b.label));
});

// Fill gaps for year-based data if continuous
let continuousData = sortedData;
const isYearData = sortedData.every(
    (d) =>
        !isNaN(Number(d.label)) &&
        Number(d.label) > 1900 &&
        Number(d.label) < 2100,
);

if (isYearData && sortedData.length > 0) {
    const minYear = Number(sortedData[0].label);
    const maxYear = Number(sortedData[sortedData.length - 1].label);
    const start = minYear;
    const end = minYear === maxYear ? maxYear + 1 : maxYear;

    // Create map for quick lookup
    const dataMap = new Map(sortedData.map((d) => [Number(d.label), d.value]));

    const fullData = [];
    for (let y = start; y <= end; y++) {
        fullData.push({
            label: String(y),
            value: dataMap.get(y) || 0,
        });
    }
    continuousData = fullData;
}

// Safe color mapping for Tailwind
const getColorClasses = (c: string) => {
    switch (c) {
        case "emerald-500":
            return {
                text: "text-emerald-500",
                bar: "from-emerald-500/40 to-emerald-500",
                hover: "hover:to-emerald-400", // valid contrast
            };
        case "purple-500":
            return {
                text: "text-purple-500",
                bar: "from-purple-500/40 to-purple-500",
                hover: "hover:to-purple-400",
            };
        default:
            return {
                text: "text-premium-purple",
                bar: "from-premium-purple/40 to-premium-purple",
                hover: "hover:to-premium-accent",
            };
    }
};

const colors = getColorClasses(color);

const maxValue = Math.max(...continuousData.map((d) => d.value), 1);
---

<div
    class={`glass-card border border-border-main rounded-3xl p-6 ${height} flex flex-col`}
>
    {
        showTitle && (
            <h4 class="text-sm font-bold text-text-main uppercase tracking-wider mb-6 flex items-center gap-2">
                <svg
                    xmlns="http://www.w3.org/2000/svg"
                    class={`w-4 h-4 ${colors.text}`}
                    viewBox="0 0 24 24"
                    fill="none"
                    stroke="currentColor"
                    stroke-width="2"
                    stroke-linecap="round"
                    stroke-linejoin="round"
                >
                    <line x1="18" y1="20" x2="18" y2="10" />
                    <line x1="12" y1="20" x2="12" y2="4" />
                    <line x1="6" y1="20" x2="6" y2="14" />
                </svg>
                {title}
            </h4>
        )
    }

    {
        continuousData.length > 0 ? (
            <div class="flex-1 flex flex-col">
                <div class="flex-1 flex items-end gap-1 min-h-[100px] mb-4 mt-8 group/chart">
                    {continuousData.map((d) => {
                        const barHeight = (d.value / maxValue) * 100;
                        return (
                            <div class="flex-1 flex flex-col items-center group/bar relative h-full justify-end">
                                {/* Bar Label (Visible always) */}
                                <span
                                    class={`absolute -top-6 text-[10px] font-bold ${colors.text} opacity-100 transition-opacity pointer-events-none whitespace-nowrap z-20`}
                                >
                                    {d.value}
                                </span>

                                {/* Tooltip */}
                                <div class="absolute bottom-full mb-2 bg-slate-800 text-white text-[10px] font-bold px-2 py-1 rounded opacity-0 group-hover/bar:opacity-100 transition-opacity whitespace-nowrap z-20 pointer-events-none shadow-xl border border-white/10">
                                    {d.label}: {d.value}{" "}
                                    {d.value === 1
                                        ? valueLabel
                                        : `${valueLabel}s`}
                                    <div class="absolute -bottom-1 left-1/2 -translate-x-1/2 w-2 h-2 bg-slate-800 rotate-45" />
                                </div>

                                {/* Bar */}
                                <div
                                    class={`w-full bg-gradient-to-t ${colors.bar} ${colors.hover} transition-all duration-500 rounded-t-sm shadow-sm opacity-90 hover:!opacity-100`}
                                    style={`height: ${Math.max(barHeight, 4)}%`}
                                />
                            </div>
                        );
                    })}
                </div>

                {/* Legend - Labels */}
                <div class="flex justify-between text-[10px] font-bold text-text-secondary uppercase tracking-tight border-t border-border-main pt-2">
                    {(() => {
                        // Logic to show reasonable amount of labels
                        const count = continuousData.length;
                        const first = continuousData[0];
                        const last = continuousData[count - 1];

                        // Always show first and last
                        const points = [first];

                        if (count > 5) {
                            const step = Math.floor(count / 4);
                            for (let i = 1; i < 4; i++) {
                                const idx = i * step;
                                if (idx < count - 1) {
                                    points.push(continuousData[idx]);
                                }
                            }
                        }

                        points.push(last);
                        const uniquePoints = [...new Set(points)]; // dedupe objects not trivial but labels are unique

                        return (
                            <>
                                {uniquePoints.map((p, idx) => {
                                    let alignClass = "";
                                    if (idx === 0) alignClass = "";
                                    else if (idx === uniquePoints.length - 1)
                                        alignClass = "";
                                    else alignClass = "hidden sm:block";

                                    return (
                                        <span class={alignClass}>
                                            {p.label}
                                        </span>
                                    );
                                })}
                            </>
                        );
                    })()}
                </div>
            </div>
        ) : (
            <div class="flex-1 flex items-center justify-center text-text-secondary italic text-sm">
                Nenhum dado disponível.
            </div>
        )
    }
</div>
